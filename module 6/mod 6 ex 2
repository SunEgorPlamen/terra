#Последовательный запуск:

#Здесь потоки будут выполняться последовательно друг за другом.

import time

def get_thread(thread_name):
    time.sleep(1)
    print(f"Поток {thread_name}")

start_time_seq = time.time()  # фиксируем начало измерения времени

for i in range(5):
    get_thread(f"Поток_{i+1}")  # каждая итерация ждёт 1 сек., всего ~5 секунд ожидания

end_time_seq = time.time()     # фиксируем конец измерения времени
seq_execution_time = end_time_seq - start_time_seq
print(f"Время последовательного выполнения: {seq_execution_time:.2f} секунды")
#Параллельный запуск:

#Теперь запустим потоки параллельно с помощью механизма многопоточной обработки.

import threading
import time

def get_thread(thread_name):
    time.sleep(1)
    print(f"Поток {thread_name}")

start_time_par = time.time()   # фиксируем начало измерения времени

threads = []                   # список для хранения объектов потоков

for i in range(5):
    t = threading.Thread(target=get_thread, args=(f"Поток_{i+1}",))  # создаем потоки
    threads.append(t)
    t.start()                     # стартуем потоки одновременно

for t in threads:
    t.join()                      # ждем завершение всех потоков

end_time_par = time.time()       # фиксируем конец измерения времени
par_execution_time = end_time_par - start_time_par
print(f"Время параллельного выполнения: {par_execution_time:.2f} секунды")
#Результаты сравнения:

#При последовательном выполнении программы первый поток ожидает свою секунду, второй также ждет свою секунду и так далее. Таким образом, общее время выполнения примерно равно сумме времен отдельных потоков (5 потоков × 1 секунда ожидания =5 секунд).

#При параллельном запуске все потоки начинают своё выполнение практически одновременно. Поэтому суммарная продолжительность выполнения будет равна примерно максимальному времени отдельного потока (~1 секунде).



